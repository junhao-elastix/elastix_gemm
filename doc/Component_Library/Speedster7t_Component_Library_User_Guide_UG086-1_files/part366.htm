<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Simultaneous Memory Operations</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part365.htm">&lt; Previous</a><span> | </span><a href="../Speedster7t_Component_Library_User_Guide_UG086-1.html">Contents</a><span> | </span><a href="part367.htm">Next &gt;</a></p><h3 style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark488">&zwnj;</a>Simultaneous Memory Operations</h3><p class="s3" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">Memory operations may be performed simultaneously from both sides of the memory. However, there is a restriction regarding memory collisions. A memory collision is defined as the condition where both ports access the same memory location(s) within the same clock cycle (both ports connected to the same clock), or within a fixed time window (if each port is connected to a different clock). If one of the ports is writing an address while the other port is reading the same address (qualified with overlapping write enables per bit), the write operation takes precedence, but the read data is invalid. The data may be reliably read on the next cycle if there is no longer a write collision.</p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part365.htm">&lt; Previous</a><span> | </span><a href="../Speedster7t_Component_Library_User_Guide_UG086-1.html">Contents</a><span> | </span><a href="part367.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
