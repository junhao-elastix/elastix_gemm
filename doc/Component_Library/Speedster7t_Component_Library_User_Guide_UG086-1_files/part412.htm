<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Inference</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part411.htm">&lt; Previous</a><span> | </span><a href="../Speedster7t_Component_Library_User_Guide_UG086-1.html">Contents</a><span> | </span><a href="part413.htm">Next &gt;</a></p><p class="s25" style="padding-top: 18pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark534">&zwnj;</a>Inference<a name="bookmark576">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><span><img width="673" height="779" alt="image" src="Image_517.png"/></span></p><p class="s3" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">The ACX_LRAM2K_SDP is inferrable using RTL constructs commonly used to infer synchronous and combinatorial RAMs and ROMs with a variety of clock enable and reset schemes and polarities.</p><p style="padding-top: 5pt;text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-left: 14pt;text-indent: 0pt;text-align: left;">//---------------------------------------------------------------------------------</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">//</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">// Copyright (c) 2021 Achronix Semiconductor Corp.</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">// All Rights Reserved.</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">//</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">// This Software constitutes an unpublished work and contains</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">// valuable proprietary information and trade secrets belonging</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">// to Achronix Semiconductor Corp.</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">//</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">// Permission is hereby granted to use this Software including</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">// without limitation the right to copy, modify, merge or distribute</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">// copies of the software subject to the following condition:</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">//</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">// The above copyright notice and this permission notice shall</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">// be included in in all copies of the Software.</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">//</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">// The Software is provided “as is” without warranty of any kind</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">// expressed or implied, including but not limited to the warranties</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">// of merchantability fitness for a particular purpose and non-infringement,</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">// in no event shall the copyright holder be liable for any claim,</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">// damages, or other liability for any damages or other liability,</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">// whether an action of contract, tort or otherwise, arising from,</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">// out of or in connection with the Software</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">//</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">//</p><p style="padding-top: 3pt;text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-left: 14pt;text-indent: 0pt;text-align: left;">//---------------------------------------------------------------------------------</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">// Design: SDP memory inference</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">//    Decides between BRAM and LRAM based on the requested size</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">//    Restriction that read and write ports must be of the same dimensions</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">//---------------------------------------------------------------------------------</p><p style="padding-top: 3pt;text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 14pt;text-indent: 0pt;text-align: left;">`timescale 1ps / 1ps</p><p style="padding-top: 3pt;text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 14pt;text-indent: 0pt;line-height: 120%;text-align: left;">module sdpram_infer #(</p><p style="padding-left: 34pt;text-indent: 0pt;text-align: left;">parameter   ADDR_WIDTH  = <span style=" color: #090;">0</span>,</p><p style="padding-top: 1pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">parameter   DATA_WIDTH  = <span style=" color: #090;">0</span>,</p><p style="padding-top: 1pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">parameter   OUT_REG_EN  = <span style=" color: #090;">0</span>,</p><p style="padding-top: 1pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">parameter   INIT_FILE_NAME = <span style=" color: #036;">&quot;&quot;</span></p><p style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">)</p><p style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">(</p><p class="s37" style="padding-top: 1pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">// Clocks and resets</p><p style="padding-top: 1pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">input wire         wr_clk,</p><p style="padding-top: 1pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">input wire         rd_clk,</p><p style="padding-top: 3pt;text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-left: 34pt;text-indent: 0pt;text-align: left;">// Enables</p><p style="padding-top: 1pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">input wire         we,</p><p style="padding-top: 1pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">input wire         rd_en,</p><p style="padding-top: 1pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">input wire         rstreg,</p><p style="padding-top: 3pt;text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-left: 34pt;text-indent: 0pt;text-align: left;">// Address and data</p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:32.0832pt" cellspacing="0"><tr style="height:11pt"><td style="width:32pt"><p class="s35" style="padding-right: 2pt;text-indent: 0pt;line-height: 9pt;text-align: center;">input</p></td><td style="width:119pt"><p class="s35" style="padding-left: 4pt;text-indent: 0pt;line-height: 9pt;text-align: left;">wire [ADDR_WIDTH-<span style=" color: #090;">1</span>:<span style=" color: #090;">0</span>]</p></td><td style="width:52pt"><p class="s35" style="padding-left: 7pt;text-indent: 0pt;line-height: 9pt;text-align: center;">wr_addr,</p></td></tr><tr style="height:11pt"><td style="width:32pt"><p class="s35" style="padding-right: 2pt;text-indent: 0pt;line-height: 9pt;text-align: center;">input</p></td><td style="width:119pt"><p class="s35" style="padding-left: 4pt;text-indent: 0pt;line-height: 9pt;text-align: left;">wire [ADDR_WIDTH-<span style=" color: #090;">1</span>:<span style=" color: #090;">0</span>]</p></td><td style="width:52pt"><p class="s35" style="padding-left: 7pt;text-indent: 0pt;line-height: 9pt;text-align: center;">rd_addr,</p></td></tr><tr style="height:11pt"><td style="width:32pt"><p class="s35" style="padding-right: 2pt;text-indent: 0pt;line-height: 8pt;text-align: center;">input</p></td><td style="width:119pt"><p class="s35" style="padding-left: 4pt;text-indent: 0pt;line-height: 8pt;text-align: left;">wire [DATA_WIDTH-<span style=" color: #090;">1</span>:<span style=" color: #090;">0</span>]</p></td><td style="width:52pt"><p class="s35" style="padding-left: 7pt;text-indent: 0pt;line-height: 8pt;text-align: center;">wr_data,</p></td></tr></table><p style="padding-top: 3pt;text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-left: 34pt;text-indent: 0pt;text-align: left;">// Output</p><p style="padding-top: 1pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">output reg [DATA_WIDTH-<span style=" color: #090;">1</span>:<span style=" color: #090;">0</span>]  rd_data</p><p style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">);</p><p style="padding-top: 3pt;text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-left: 34pt;text-indent: 0pt;text-align: left;">// Determine if size is small enough for an LRAM</p><p style="padding-top: 1pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">localparam MEM_LRAM = ( ((DATA_WIDTH &lt;= <span style=" color: #090;">36</span>) &amp;&amp; (ADDR_WIDTH &lt;= <span style=" color: #090;">6</span>)) ||</p><p style="padding-top: 1pt;padding-left: 153pt;text-indent: 0pt;line-height: 120%;text-align: left;">((DATA_WIDTH &lt;= <span style=" color: #090;">72</span>) &amp;&amp; (ADDR_WIDTH &lt;= <span style=" color: #090;">5</span>)) || ((DATA_WIDTH &lt;= <span style=" color: #090;">144</span>) &amp;&amp; (ADDR_WIDTH &lt;= <span style=" color: #090;">4</span>)) ) ? <span style=" color: #090;">1 </span>: <span style=" color: #090;">0</span>;</p><p style="padding-top: 1pt;text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 34pt;text-indent: 0pt;text-align: left;">localparam WIDE_BRAM = (DATA_WIDTH &gt; <span style=" color: #090;">72</span>) ? <span style=" color: #090;">1 </span>: <span style=" color: #090;">0</span>;</p><p style="padding-top: 3pt;text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 34pt;text-indent: 0pt;line-height: 120%;text-align: left;"><span style=" color: #008100;">// Define combinatorial and registered outputs from memory array </span>logic [DATA_WIDTH-<span style=" color: #090;">1</span>:<span style=" color: #090;">0</span>] rd_data_int;</p><p style="padding-left: 34pt;text-indent: 0pt;line-height: 120%;text-align: left;">logic [DATA_WIDTH-<span style=" color: #090;">1</span>:<span style=" color: #090;">0</span>] rd_data_reg; logic        read_collision; always @(posedge rd_clk)</p><p class="s33" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">if <span class="p">(~rstreg)</span></p><p style="padding-top: 1pt;padding-left: 74pt;text-indent: 0pt;text-align: left;">rd_data_reg &lt;= {DATA_WIDTH{<span style=" color: #090;">1</span>&#39;b0}};</p><p class="s33" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">else</p><p style="padding-top: 1pt;padding-left: 74pt;text-indent: 0pt;text-align: left;">rd_data_reg &lt;= rd_data_int;</p><p style="padding-top: 3pt;text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-left: 34pt;text-indent: 0pt;text-align: left;">// Need a generate block to apply the appropriate syn_ramstyle to the memory array</p><p style="padding-top: 1pt;padding-left: 34pt;text-indent: 0pt;line-height: 120%;text-align: left;"><span style=" color: #008100;">// Rest of the the code has to be within the generate block to access that variable </span>generate <span class="s33">if </span>( MEM_LRAM == <span style=" color: #090;">1</span>) begin : gb_lram</p><p style="padding-top: 1pt;text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 54pt;text-indent: 0pt;text-align: left;">logic [DATA_WIDTH-<span style=" color: #090;">1</span>:<span style=" color: #090;">0</span>] mem [(<span style=" color: #090;">2</span>**ADDR_WIDTH)-<span style=" color: #090;">1</span>:<span style=" color: #090;">0</span>] <span style=" color: #008100;">/* synthesis syn_ramstyle = &quot;logic&quot; */</span>;</p><p style="padding-top: 3pt;text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">// If an initialisation file exists, then initialise the memory</p><p style="padding-top: 1pt;padding-left: 74pt;text-indent: -19pt;line-height: 120%;text-align: left;"><span class="s33">if </span>( INIT_FILE_NAME != <span style=" color: #036;">&quot;&quot; </span>) begin : gb_init initial</p><p style="padding-left: 93pt;text-indent: 0pt;text-align: left;">$readmemh( INIT_FILE_NAME, mem );</p><p style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">end</p><p style="padding-top: 3pt;text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">// Writing. Inference does not currently support byte enables</p><p style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;line-height: 120%;text-align: left;"><span style=" color: #008100;">// Also generate the signals to detect if there is a memory collision </span>logic [ADDR_WIDTH-<span style=" color: #090;">1</span>:<span style=" color: #090;">0</span>] wr_addr_d;</p><p style="padding-left: 54pt;text-indent: 0pt;text-align: left;">always @(posedge wr_clk)</p><p class="s33" style="padding-top: 1pt;padding-left: 74pt;text-indent: 0pt;text-align: left;">if<span class="p">( we ) begin</span></p><p style="padding-top: 1pt;padding-left: 93pt;text-indent: 0pt;line-height: 120%;text-align: left;">mem[wr_addr] &lt;= wr_data; wr_addr_d  &lt;= wr_addr;</p><p style="padding-left: 74pt;text-indent: 0pt;text-align: left;">end</p><p style="padding-top: 3pt;text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">// LRAM only supports the WRITE_FIRST mode. So if rd_addr = wr_addr then</p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">// write takes priority and read value is invalid</p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">// The value from the array is combinatorial, (this is different than for BRAM)</p><p class="s37" style="padding-top: 1pt;padding-left: 14pt;text-indent: 39pt;line-height: 136%;text-align: left;">// Write address is effective on the cycle it is writing to the memory, (i.e. it is registered)</p><p style="padding-left: 54pt;text-indent: 0pt;line-height: 8pt;text-align: left;">assign read_collision = (wr_addr_d == rd_addr);</p><p style="padding-top: 3pt;text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 54pt;text-indent: 0pt;text-align: left;">assign rd_data_int = (read_collision) ? {DATA_WIDTH{<span style=" color: #090;">1</span>&#39;bx}} : mem[rd_addr];</p><p style="padding-top: 3pt;text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 34pt;text-indent: 0pt;text-align: left;">end</p><p style="padding-top: 1pt;padding-left: 34pt;text-indent: 0pt;text-align: left;"><span class="s33">else if </span>( WIDE_BRAM == <span style=" color: #090;">1 </span>) begin : gb_wide_bram</p><p style="text-indent: 0pt;text-align: left;"><span><img width="2" height="866" alt="image" src="Image_518.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="2" height="866" alt="image" src="Image_519.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-left: 14pt;text-indent: 0pt;text-align: left;">*/<span style=" color: #000;">;</span></p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">logic [DATA_WIDTH-<span style=" color: #090;">1</span>:<span style=" color: #090;">0</span>] mem [(<span style=" color: #090;">2</span>**ADDR_WIDTH)-<span style=" color: #090;">1</span>:<span style=" color: #090;">0</span>] <span style=" color: #008100;">/* synthesis syn_ramstyle = &quot;large_ram&quot;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">// If an initialisation file exists, then initialise the memory</p><p style="padding-top: 1pt;padding-left: 25pt;text-indent: -19pt;line-height: 120%;text-align: left;"><span class="s33">if </span>( INIT_FILE_NAME != <span style=" color: #036;">&quot;&quot; </span>) begin : gb_init initial</p><p style="padding-left: 45pt;text-indent: 0pt;text-align: left;">$readmemh( INIT_FILE_NAME, mem );</p><p style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">end</p><p style="padding-top: 3pt;text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 120%;text-align: left;">// Writing. Inference does not currently support byte enables <span style=" color: #000;">always @(posedge wr_clk)</span></p><p class="s33" style="padding-left: 74pt;text-indent: 0pt;line-height: 120%;text-align: left;">if<span class="p">( we ) begin</span></p><p style="padding-left: 93pt;text-indent: 0pt;text-align: left;">mem[wr_addr] &lt;= wr_data;</p><p style="padding-top: 1pt;padding-left: 74pt;text-indent: 0pt;text-align: left;">end</p><p style="padding-top: 3pt;text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">// BRAM supports WRITE_FIRST mode only, (write takes precedence over read)</p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">// Calculate if there will be a collision</p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">// write takes priority and read value is invalid</p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;line-height: 120%;text-align: left;">// Both wr_addr and rd_addr have registered operations on the memory array <span style=" color: #000;">assign read_collision = (wr_addr == rd_addr) &amp;&amp; we;</span></p><p style="padding-top: 1pt;text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 54pt;text-indent: 0pt;text-align: left;">always @(posedge rd_clk)</p><p class="s33" style="padding-top: 1pt;padding-left: 74pt;text-indent: 0pt;line-height: 120%;text-align: left;">if<span class="p">( rd_en ) begin</span></p><p class="s37" style="padding-left: 93pt;text-indent: 0pt;text-align: left;">// Read collisions cannot be modelled in synthesis, so use solely in simulation</p><p class="s37" style="padding-top: 1pt;padding-left: 93pt;text-indent: 0pt;text-align: left;">// synthesis synthesis_off</p><p class="s33" style="padding-top: 1pt;padding-left: 93pt;text-indent: 0pt;text-align: left;">if<span class="p">( read_collision )</span></p><p style="padding-top: 1pt;padding-left: 113pt;text-indent: 0pt;text-align: left;">rd_data_int &lt;= {ADDR_WIDTH{<span style=" color: #090;">1</span>&#39;bx}};</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 34pt;text-indent: 0pt;text-align: left;">end</p><p class="s33" style="padding-top: 1pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">else</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">end</p><p class="s33" style="padding-top: 1pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">else</p><p class="s37" style="padding-top: 1pt;padding-left: 22pt;text-indent: -19pt;line-height: 120%;text-align: left;">// synthesis synthesis_on <span style=" color: #000;">rd_data_int &lt;= mem[rd_addr];</span></p><p style="padding-top: 1pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">begin : gb_bram</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 8pt;text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-left: 14pt;text-indent: 0pt;text-align: left;">*/<span style=" color: #000;">;</span></p><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">logic [DATA_WIDTH-<span style=" color: #090;">1</span>:<span style=" color: #090;">0</span>] mem [(<span style=" color: #090;">2</span>**ADDR_WIDTH)-<span style=" color: #090;">1</span>:<span style=" color: #090;">0</span>] <span style=" color: #008100;">/* synthesis syn_ramstyle = &quot;block_ram&quot;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">// If an initialisation file exists, then initialise the memory</p><p style="padding-top: 1pt;padding-left: 25pt;text-indent: -19pt;line-height: 120%;text-align: left;"><span class="s33">if </span>( INIT_FILE_NAME != <span style=" color: #036;">&quot;&quot; </span>) begin : gb_init initial</p><p style="padding-left: 45pt;text-indent: 0pt;text-align: left;">$readmemh( INIT_FILE_NAME, mem );</p><p style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">end</p><p style="padding-top: 3pt;text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 120%;text-align: left;">// Writing. Inference does not currently support byte enables <span style=" color: #000;">always @(posedge wr_clk)</span></p><p class="s33" style="padding-left: 74pt;text-indent: 0pt;line-height: 120%;text-align: left;">if<span class="p">( we ) begin</span></p><p style="padding-left: 93pt;text-indent: 0pt;text-align: left;">mem[wr_addr] &lt;= wr_data;</p><p style="padding-top: 1pt;padding-left: 74pt;text-indent: 0pt;text-align: left;">end</p><p style="padding-top: 3pt;text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">// BRAM supports WRITE_FIRST mode only, (write takes precedence over read)</p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">// Calculate if there will be a collision</p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">// write takes priority and read value is invalid</p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;line-height: 120%;text-align: left;">// Both wr_addr and rd_addr have registered operations on the memory array <span style=" color: #000;">assign read_collision = (wr_addr == rd_addr) &amp;&amp; we;</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="2" height="866" alt="image" src="Image_520.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="2" height="866" alt="image" src="Image_521.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="673" height="273" alt="image" src="Image_522.png"/></span></p><p style="padding-top: 1pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">always @(posedge rd_clk)</p><p class="s33" style="padding-top: 1pt;padding-left: 67pt;text-indent: 0pt;line-height: 120%;text-align: left;">if<span class="p">( rd_en ) begin</span></p><p class="s37" style="padding-left: 86pt;text-indent: 0pt;text-align: left;">// Read collisions cannot be modelled in synthesis, so use solely in simulation</p><p class="s37" style="padding-top: 1pt;padding-left: 86pt;text-indent: 0pt;text-align: left;">// synthesis synthesis_off</p><p class="s33" style="padding-top: 1pt;padding-left: 86pt;text-indent: 0pt;text-align: left;">if<span class="p">( read_collision )</span></p><p style="padding-top: 1pt;padding-left: 106pt;text-indent: 0pt;text-align: left;">rd_data_int &lt;= {ADDR_WIDTH{<span style=" color: #090;">1</span>&#39;bx}};</p><p class="s33" style="padding-top: 1pt;padding-left: 86pt;text-indent: 0pt;text-align: left;">else</p><p class="s37" style="padding-top: 1pt;padding-left: 106pt;text-indent: -19pt;line-height: 120%;text-align: left;">// synthesis synthesis_on <span style=" color: #000;">rd_data_int &lt;= mem[rd_addr];</span></p><p style="padding-left: 27pt;text-indent: 39pt;line-height: 120%;text-align: left;">end end endgenerate</p><p style="padding-top: 1pt;text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-left: 27pt;text-indent: 0pt;line-height: 120%;text-align: left;">// Select output based on whether output register is enabled <span style=" color: #000;">assign rd_data = (OUT_REG_EN) ? rd_data_reg : rd_data_int;</span></p><p style="padding-top: 1pt;text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">endmodule : sdpram_infer</p><p style="padding-top: 1pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">always @(posedge rd_clk)</p><p class="s33" style="padding-top: 1pt;padding-left: 67pt;text-indent: 0pt;line-height: 120%;text-align: left;">if<span class="p">( rd_en ) begin</span></p><p class="s37" style="padding-left: 86pt;text-indent: 0pt;text-align: left;">// Read collisions cannot be modelled in synthesis, so use solely in simulation</p><p class="s37" style="padding-top: 1pt;padding-left: 86pt;text-indent: 0pt;text-align: left;">// synthesis synthesis_off</p><p class="s33" style="padding-top: 1pt;padding-left: 86pt;text-indent: 0pt;text-align: left;">if<span class="p">( read_collision )</span></p><p style="padding-top: 1pt;padding-left: 106pt;text-indent: 0pt;text-align: left;">rd_data_int &lt;= {ADDR_WIDTH{<span style=" color: #090;">1</span>&#39;bx}};</p><p class="s33" style="padding-top: 1pt;padding-left: 86pt;text-indent: 0pt;text-align: left;">else</p><p class="s37" style="padding-top: 1pt;padding-left: 106pt;text-indent: -19pt;line-height: 120%;text-align: left;">// synthesis synthesis_on <span style=" color: #000;">rd_data_int &lt;= mem[rd_addr];</span></p><p style="padding-left: 27pt;text-indent: 39pt;line-height: 120%;text-align: left;">end end endgenerate</p><p style="padding-top: 1pt;text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-left: 27pt;text-indent: 0pt;line-height: 120%;text-align: left;">// Select output based on whether output register is enabled <span style=" color: #000;">assign rd_data = (OUT_REG_EN) ? rd_data_reg : rd_data_int;</span></p><p style="padding-top: 1pt;text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">endmodule : sdpram_infer</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 1pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">always @(posedge rd_clk)</p><p class="s33" style="padding-top: 1pt;padding-left: 67pt;text-indent: 0pt;line-height: 120%;text-align: left;">if<span class="p">( rd_en ) begin</span></p><p class="s37" style="padding-left: 86pt;text-indent: 0pt;text-align: left;">// Read collisions cannot be modelled in synthesis, so use solely in simulation</p><p class="s37" style="padding-top: 1pt;padding-left: 86pt;text-indent: 0pt;text-align: left;">// synthesis synthesis_off</p><p class="s33" style="padding-top: 1pt;padding-left: 86pt;text-indent: 0pt;text-align: left;">if<span class="p">( read_collision )</span></p><p style="padding-top: 1pt;padding-left: 106pt;text-indent: 0pt;text-align: left;">rd_data_int &lt;= {ADDR_WIDTH{<span style=" color: #090;">1</span>&#39;bx}};</p><p class="s33" style="padding-top: 1pt;padding-left: 86pt;text-indent: 0pt;text-align: left;">else</p><p class="s37" style="padding-top: 1pt;padding-left: 106pt;text-indent: -19pt;line-height: 120%;text-align: left;">// synthesis synthesis_on <span style=" color: #000;">rd_data_int &lt;= mem[rd_addr];</span></p><p style="padding-left: 27pt;text-indent: 39pt;line-height: 120%;text-align: left;">end end endgenerate</p><p style="padding-top: 1pt;text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-left: 27pt;text-indent: 0pt;line-height: 120%;text-align: left;">// Select output based on whether output register is enabled <span style=" color: #000;">assign rd_data = (OUT_REG_EN) ? rd_data_reg : rd_data_int;</span></p><p style="padding-top: 1pt;text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;">endmodule : sdpram_infer</p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part411.htm">&lt; Previous</a><span> | </span><a href="../Speedster7t_Component_Library_User_Guide_UG086-1.html">Contents</a><span> | </span><a href="part413.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
