<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Achronix Software Development Kit (SDK): Achronix_PCIe.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Achronix Software Development Kit (SDK)
   </div>
   <div id="projectbrief">Copyright (c) 2022-2023 Achronix Semiconductor. Some Rights Reserved.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('Achronix__PCIe_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Achronix_PCIe.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file implements the functions defined in <a class="el" href="Achronix__PCIe_8h.html" title="This file defines a translation layer, also called a &quot;shim&quot;, between the user-mode PCIe API and the k...">Achronix_PCIe.h</a>.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="Achronix__PCIe_8h_source.html">Achronix_PCIe.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Achronix__version_8h_source.html">Achronix_version.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Achronix__logging_8h_source.html">Achronix_logging.h</a>&quot;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;fcntl.h&gt;</code><br />
<code>#include &lt;sys/mman.h&gt;</code><br />
<code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;glob.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab9dbd561ce40a9a18deeb72dd2ef4db6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Achronix__PCIe_8c.html#ab9dbd561ce40a9a18deeb72dd2ef4db6">acx_pcie_get_sdk_version</a> (uint32_t *major_version, uint32_t *minor_version, uint32_t *patch_version)</td></tr>
<tr class="memdesc:ab9dbd561ce40a9a18deeb72dd2ef4db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets version information about the SDK.  <a href="Achronix__PCIe_8c.html#ab9dbd561ce40a9a18deeb72dd2ef4db6">More...</a><br /></td></tr>
<tr class="separator:ab9dbd561ce40a9a18deeb72dd2ef4db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fbda6a3d1a4e388edc8f3a72df492e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Achronix__PCIe_8c.html#a46fbda6a3d1a4e388edc8f3a72df492e">acx_pcie_get_num_devices</a> ()</td></tr>
<tr class="memdesc:a46fbda6a3d1a4e388edc8f3a72df492e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of devices bound to the used driver.  <a href="Achronix__PCIe_8c.html#a46fbda6a3d1a4e388edc8f3a72df492e">More...</a><br /></td></tr>
<tr class="separator:a46fbda6a3d1a4e388edc8f3a72df492e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e41cb2aefcea889ecbb674e31c4d703"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__lib__common.html#ga941f9eec6e2e97a778423e94e6e4025b">ACX_SDK_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Achronix__PCIe_8c.html#a8e41cb2aefcea889ecbb674e31c4d703">acx_pcie_get_device_info</a> (<a class="el" href="Achronix__PCIe_8h.html#ac4db1ffd6852a9dd694b70db54be5af3">ACX_PCIE_dev_handle</a> device_hand, <a class="el" href="structACX__PCIE__device__info.html">ACX_PCIE_device_info</a> *info)</td></tr>
<tr class="memdesc:a8e41cb2aefcea889ecbb674e31c4d703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the passed-in struct with information from the passed-in device’s config space.  <a href="Achronix__PCIe_8c.html#a8e41cb2aefcea889ecbb674e31c4d703">More...</a><br /></td></tr>
<tr class="separator:a8e41cb2aefcea889ecbb674e31c4d703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e19b14f8c8fb7d142ab213fffc9f0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Achronix__PCIe_8h.html#ac4db1ffd6852a9dd694b70db54be5af3">ACX_PCIE_dev_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Achronix__PCIe_8c.html#a64e19b14f8c8fb7d142ab213fffc9f0f">acx_pcie_open_device_hand_idx</a> (uint32_t device_id)</td></tr>
<tr class="memdesc:a64e19b14f8c8fb7d142ab213fffc9f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an ACX PCIE device for use.  <a href="Achronix__PCIe_8c.html#a64e19b14f8c8fb7d142ab213fffc9f0f">More...</a><br /></td></tr>
<tr class="separator:a64e19b14f8c8fb7d142ab213fffc9f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9354e383deca85e70676e05fe6183c79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Achronix__PCIe_8h.html#ac4db1ffd6852a9dd694b70db54be5af3">ACX_PCIE_dev_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Achronix__PCIe_8c.html#a9354e383deca85e70676e05fe6183c79">acx_pcie_open_device_hand_bdf</a> (uint32_t bus, uint32_t device_num, uint32_t function)</td></tr>
<tr class="memdesc:a9354e383deca85e70676e05fe6183c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an ACX PCIE device for use.  <a href="Achronix__PCIe_8c.html#a9354e383deca85e70676e05fe6183c79">More...</a><br /></td></tr>
<tr class="separator:a9354e383deca85e70676e05fe6183c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd32e09b578d77173959a37909bb40c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Achronix__PCIe_8c.html#abd32e09b578d77173959a37909bb40c9">acx_pcie_close_device_hand</a> (<a class="el" href="Achronix__PCIe_8h.html#ac4db1ffd6852a9dd694b70db54be5af3">ACX_PCIE_dev_handle</a> device_hand)</td></tr>
<tr class="memdesc:abd32e09b578d77173959a37909bb40c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes an ACX PCIE device.  <a href="Achronix__PCIe_8c.html#abd32e09b578d77173959a37909bb40c9">More...</a><br /></td></tr>
<tr class="separator:abd32e09b578d77173959a37909bb40c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c09d57516a698e2237a1214ad6bfb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__lib__common.html#ga941f9eec6e2e97a778423e94e6e4025b">ACX_SDK_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Achronix__PCIe_8c.html#ac0c09d57516a698e2237a1214ad6bfb2">acx_pcie_get_bar_idx</a> (<a class="el" href="Achronix__PCIe_8h.html#a8d5b3f1a4089b9791bb15c422646193f">ACX_BAR_handle</a> bar_hand, uint32_t *index)</td></tr>
<tr class="memdesc:ac0c09d57516a698e2237a1214ad6bfb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the BAR index associated with a BAR handle.  <a href="Achronix__PCIe_8c.html#ac0c09d57516a698e2237a1214ad6bfb2">More...</a><br /></td></tr>
<tr class="separator:ac0c09d57516a698e2237a1214ad6bfb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa273b96373e5f39e75f08f5d897b3667"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__lib__common.html#ga941f9eec6e2e97a778423e94e6e4025b">ACX_SDK_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Achronix__PCIe_8c.html#aa273b96373e5f39e75f08f5d897b3667">acx_pcie_get_bar_size</a> (<a class="el" href="Achronix__PCIe_8h.html#ac4db1ffd6852a9dd694b70db54be5af3">ACX_PCIE_dev_handle</a> device_hand, uint32_t bar_id, uint64_t *size_ptr)</td></tr>
<tr class="memdesc:aa273b96373e5f39e75f08f5d897b3667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size (in bytes) of a device's BAR.  <a href="Achronix__PCIe_8c.html#aa273b96373e5f39e75f08f5d897b3667">More...</a><br /></td></tr>
<tr class="separator:aa273b96373e5f39e75f08f5d897b3667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980ee7fa26df733575c35f73dffd697f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__lib__common.html#ga941f9eec6e2e97a778423e94e6e4025b">ACX_SDK_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Achronix__PCIe_8c.html#a980ee7fa26df733575c35f73dffd697f">acx_pcie_get_bar_start</a> (<a class="el" href="Achronix__PCIe_8h.html#ac4db1ffd6852a9dd694b70db54be5af3">ACX_PCIE_dev_handle</a> device_hand, uint32_t bar_id, uint64_t *start_ptr)</td></tr>
<tr class="memdesc:a980ee7fa26df733575c35f73dffd697f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the starting address of a BAR in host physical memory.  <a href="Achronix__PCIe_8c.html#a980ee7fa26df733575c35f73dffd697f">More...</a><br /></td></tr>
<tr class="separator:a980ee7fa26df733575c35f73dffd697f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdf67b5ede5e7f3f4bbc315ecde19a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Achronix__PCIe_8h.html#a8d5b3f1a4089b9791bb15c422646193f">ACX_BAR_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Achronix__PCIe_8c.html#abbdf67b5ede5e7f3f4bbc315ecde19a7">acx_pcie_open_bar_hand</a> (<a class="el" href="Achronix__PCIe_8h.html#ac4db1ffd6852a9dd694b70db54be5af3">ACX_PCIE_dev_handle</a> device_hand, uint32_t bar_id)</td></tr>
<tr class="memdesc:abbdf67b5ede5e7f3f4bbc315ecde19a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a device's BAR for reading/writing.  <a href="Achronix__PCIe_8c.html#abbdf67b5ede5e7f3f4bbc315ecde19a7">More...</a><br /></td></tr>
<tr class="separator:abbdf67b5ede5e7f3f4bbc315ecde19a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a39cd5aa93936a63cc617aa1bb987c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Achronix__PCIe_8c.html#a5a39cd5aa93936a63cc617aa1bb987c7">acx_pcie_close_bar_hand</a> (<a class="el" href="Achronix__PCIe_8h.html#a8d5b3f1a4089b9791bb15c422646193f">ACX_BAR_handle</a> bar_hand)</td></tr>
<tr class="memdesc:a5a39cd5aa93936a63cc617aa1bb987c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a device's BAR from reading/writing.  <a href="Achronix__PCIe_8c.html#a5a39cd5aa93936a63cc617aa1bb987c7">More...</a><br /></td></tr>
<tr class="separator:a5a39cd5aa93936a63cc617aa1bb987c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827c5207357befc8606330318f9efe98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Achronix__PCIe_8h.html#a947d546ebc14b9e64d57e8a8a9ddfbbd">ACX_DMA_buffer_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Achronix__PCIe_8c.html#a827c5207357befc8606330318f9efe98">acx_pcie_alloc_dma_hand</a> (<a class="el" href="Achronix__PCIe_8h.html#ac4db1ffd6852a9dd694b70db54be5af3">ACX_PCIE_dev_handle</a> device_hand, uint64_t size_in_bytes, void **virtual_address, void **dma_address)</td></tr>
<tr class="memdesc:a827c5207357befc8606330318f9efe98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a buffer in the process's virtual address space, which is backed by static physical memory, that can be read/written to by the PCIE device. The returned handle is used for DMA engine transactions.  <a href="Achronix__PCIe_8c.html#a827c5207357befc8606330318f9efe98">More...</a><br /></td></tr>
<tr class="separator:a827c5207357befc8606330318f9efe98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9f5b7ab09f190c035a4d877e33cc4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Achronix__PCIe_8c.html#a8a9f5b7ab09f190c035a4d877e33cc4e">acx_pcie_free_dma_hand</a> (<a class="el" href="Achronix__PCIe_8h.html#ac4db1ffd6852a9dd694b70db54be5af3">ACX_PCIE_dev_handle</a> device_hand, <a class="el" href="Achronix__PCIe_8h.html#a947d546ebc14b9e64d57e8a8a9ddfbbd">ACX_DMA_buffer_handle</a> dma_buffer_hand)</td></tr>
<tr class="memdesc:a8a9f5b7ab09f190c035a4d877e33cc4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a DMA buffer that was alloced with <a class="el" href="Achronix__PCIe_8h.html#a827c5207357befc8606330318f9efe98" title="Allocates a buffer in the process&#39;s virtual address space, which is backed by static physical memory,...">acx_pcie_alloc_dma_hand()</a>.  <a href="Achronix__PCIe_8c.html#a8a9f5b7ab09f190c035a4d877e33cc4e">More...</a><br /></td></tr>
<tr class="separator:a8a9f5b7ab09f190c035a4d877e33cc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f25f9c01eaeb561b9943af9777d7052"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Achronix__PCIe_8c.html#a4f25f9c01eaeb561b9943af9777d7052">acx_pcie_read_uint8</a> (<a class="el" href="Achronix__PCIe_8h.html#a8d5b3f1a4089b9791bb15c422646193f">ACX_BAR_handle</a> bar_hand, uint64_t offset, uint8_t *buffer, uint32_t count)</td></tr>
<tr class="memdesc:a4f25f9c01eaeb561b9943af9777d7052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read unformatted 8-bit unsigned data from a devices BAR.  <a href="Achronix__PCIe_8c.html#a4f25f9c01eaeb561b9943af9777d7052">More...</a><br /></td></tr>
<tr class="separator:a4f25f9c01eaeb561b9943af9777d7052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97031690386ab74efc147e9dd8047092"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Achronix__PCIe_8c.html#a97031690386ab74efc147e9dd8047092">acx_pcie_read_uint16</a> (<a class="el" href="Achronix__PCIe_8h.html#a8d5b3f1a4089b9791bb15c422646193f">ACX_BAR_handle</a> bar_hand, uint64_t offset, uint16_t *buffer, uint32_t count)</td></tr>
<tr class="memdesc:a97031690386ab74efc147e9dd8047092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read unformatted 16-bit unsigned data from a devices BAR.  <a href="Achronix__PCIe_8c.html#a97031690386ab74efc147e9dd8047092">More...</a><br /></td></tr>
<tr class="separator:a97031690386ab74efc147e9dd8047092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba025559ae6fa6df6228ad49a01344e2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Achronix__PCIe_8c.html#aba025559ae6fa6df6228ad49a01344e2">acx_pcie_read_uint32</a> (<a class="el" href="Achronix__PCIe_8h.html#a8d5b3f1a4089b9791bb15c422646193f">ACX_BAR_handle</a> bar_hand, uint64_t offset, uint32_t *buffer, uint32_t count)</td></tr>
<tr class="memdesc:aba025559ae6fa6df6228ad49a01344e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read unformatted 32-bit unsigned data from a devices BAR.  <a href="Achronix__PCIe_8c.html#aba025559ae6fa6df6228ad49a01344e2">More...</a><br /></td></tr>
<tr class="separator:aba025559ae6fa6df6228ad49a01344e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ac9448a3e5f002918f4f7156904441"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Achronix__PCIe_8c.html#a74ac9448a3e5f002918f4f7156904441">acx_pcie_read_uint64</a> (<a class="el" href="Achronix__PCIe_8h.html#a8d5b3f1a4089b9791bb15c422646193f">ACX_BAR_handle</a> bar_hand, uint64_t offset, uint64_t *buffer, uint32_t count)</td></tr>
<tr class="memdesc:a74ac9448a3e5f002918f4f7156904441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read unformatted 64-bit unsigned data from a devices BAR.  <a href="Achronix__PCIe_8c.html#a74ac9448a3e5f002918f4f7156904441">More...</a><br /></td></tr>
<tr class="separator:a74ac9448a3e5f002918f4f7156904441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301b8e0a78e9d33ae8eea4066dc9520d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__lib__common.html#ga941f9eec6e2e97a778423e94e6e4025b">ACX_SDK_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Achronix__PCIe_8c.html#a301b8e0a78e9d33ae8eea4066dc9520d">acx_pcie_write_uint8</a> (<a class="el" href="Achronix__PCIe_8h.html#a8d5b3f1a4089b9791bb15c422646193f">ACX_BAR_handle</a> bar_hand, uint64_t offset, uint8_t value)</td></tr>
<tr class="memdesc:a301b8e0a78e9d33ae8eea4066dc9520d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write unformatted 8-bit unsigned data to a devices BAR.  <a href="Achronix__PCIe_8c.html#a301b8e0a78e9d33ae8eea4066dc9520d">More...</a><br /></td></tr>
<tr class="separator:a301b8e0a78e9d33ae8eea4066dc9520d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa682f757fe351b2d465b6b1772eacc65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__lib__common.html#ga941f9eec6e2e97a778423e94e6e4025b">ACX_SDK_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Achronix__PCIe_8c.html#aa682f757fe351b2d465b6b1772eacc65">acx_pcie_write_uint16</a> (<a class="el" href="Achronix__PCIe_8h.html#a8d5b3f1a4089b9791bb15c422646193f">ACX_BAR_handle</a> bar_hand, uint64_t offset, uint16_t value)</td></tr>
<tr class="memdesc:aa682f757fe351b2d465b6b1772eacc65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write unformatted 16-bit unsigned data to a devices BAR.  <a href="Achronix__PCIe_8c.html#aa682f757fe351b2d465b6b1772eacc65">More...</a><br /></td></tr>
<tr class="separator:aa682f757fe351b2d465b6b1772eacc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca38a009e6d02dd8162dde3dd8be2450"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__lib__common.html#ga941f9eec6e2e97a778423e94e6e4025b">ACX_SDK_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Achronix__PCIe_8c.html#aca38a009e6d02dd8162dde3dd8be2450">acx_pcie_write_uint32</a> (<a class="el" href="Achronix__PCIe_8h.html#a8d5b3f1a4089b9791bb15c422646193f">ACX_BAR_handle</a> bar_hand, uint64_t offset, uint32_t value)</td></tr>
<tr class="memdesc:aca38a009e6d02dd8162dde3dd8be2450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write unformatted 32-bit unsigned data to a devices BAR.  <a href="Achronix__PCIe_8c.html#aca38a009e6d02dd8162dde3dd8be2450">More...</a><br /></td></tr>
<tr class="separator:aca38a009e6d02dd8162dde3dd8be2450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfd7035cf0c0d4262e01fde49a7264f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__lib__common.html#ga941f9eec6e2e97a778423e94e6e4025b">ACX_SDK_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Achronix__PCIe_8c.html#a8cfd7035cf0c0d4262e01fde49a7264f">acx_pcie_write_uint64</a> (<a class="el" href="Achronix__PCIe_8h.html#a8d5b3f1a4089b9791bb15c422646193f">ACX_BAR_handle</a> bar_hand, uint64_t offset, uint64_t value)</td></tr>
<tr class="memdesc:a8cfd7035cf0c0d4262e01fde49a7264f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write unformatted 64-bit unsigned data to a devices BAR.  <a href="Achronix__PCIe_8c.html#a8cfd7035cf0c0d4262e01fde49a7264f">More...</a><br /></td></tr>
<tr class="separator:a8cfd7035cf0c0d4262e01fde49a7264f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9309d8e8490cf8781229e1394bc534"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__lib__common.html#ga941f9eec6e2e97a778423e94e6e4025b">ACX_SDK_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Achronix__PCIe_8c.html#adf9309d8e8490cf8781229e1394bc534">acx_pcie_interrupt_wait</a> (<a class="el" href="Achronix__PCIe_8h.html#ac4db1ffd6852a9dd694b70db54be5af3">ACX_PCIE_dev_handle</a> device_hand, uint32_t message_id, uint32_t timeout_ms)</td></tr>
<tr class="memdesc:adf9309d8e8490cf8781229e1394bc534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking wait for a device interrupt.  <a href="Achronix__PCIe_8c.html#adf9309d8e8490cf8781229e1394bc534">More...</a><br /></td></tr>
<tr class="separator:adf9309d8e8490cf8781229e1394bc534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db0fc2951f11aef93e9ff088a0612bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Achronix__PCIe_8c.html#a1db0fc2951f11aef93e9ff088a0612bc">acx_pcie_cancel_wait</a> (<a class="el" href="Achronix__PCIe_8h.html#ac4db1ffd6852a9dd694b70db54be5af3">ACX_PCIE_dev_handle</a> device_hand, uint32_t message_id)</td></tr>
<tr class="memdesc:a1db0fc2951f11aef93e9ff088a0612bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unblocks any threads waiting on the passed-in interrupt vector.  <a href="Achronix__PCIe_8c.html#a1db0fc2951f11aef93e9ff088a0612bc">More...</a><br /></td></tr>
<tr class="separator:a1db0fc2951f11aef93e9ff088a0612bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file implements the functions defined in <a class="el" href="Achronix__PCIe_8h.html" title="This file defines a translation layer, also called a &quot;shim&quot;, between the user-mode PCIe API and the k...">Achronix_PCIe.h</a>. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>(c) 2022-@showdate "%Y " Achronix Semiconductor Corporation </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a827c5207357befc8606330318f9efe98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827c5207357befc8606330318f9efe98">&#9670;&nbsp;</a></span>acx_pcie_alloc_dma_hand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Achronix__PCIe_8h.html#a947d546ebc14b9e64d57e8a8a9ddfbbd">ACX_DMA_buffer_handle</a> acx_pcie_alloc_dma_hand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Achronix__PCIe_8h.html#ac4db1ffd6852a9dd694b70db54be5af3">ACX_PCIE_dev_handle</a>&#160;</td>
          <td class="paramname"><em>device_hand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size_in_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>virtual_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>dma_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a buffer in the process's virtual address space, which is backed by static physical memory, that can be read/written to by the PCIE device. The returned handle is used for DMA engine transactions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">device_hand</td><td>A valid device handle for the device that will be allowed to read this memory </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">size_in_bytes</td><td>Size (in bytes) to allocate for the buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">virtual_address</td><td>Pointer to a void pointer that will store the virtual address of the buffer in host memory. This is the address that a user process should read/write to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dma_address</td><td>Pointer to a void pointer that will store the physical address of the buffer in host memory. This address is needed by the DMA engine, but user processes are not allowed to read or write to this address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ACX_DMA_buffer_handle if successful, or NULL for failure. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is only used when interacting directly with the PCIe API's driver translation layer. User applications will normally use higher-level functions from <a class="el" href="Achronix__device_8h.html" title="This file defines enums, structures and functions for opening, initializing, and closing a PCIe devic...">Achronix_device.h</a>. </dd>
<dd>
Memory allocated to these buffers must be statically backed by host physical memory, and therefore cannot be swapped out if the system is low on memory. Driver implementations may vary, but it is generally the user’s reasonability to make sure there is enough system memory available before trying to allocate a buffer. Failing to do so could cause system instability or crashes. A DMA buffer that was allocated for one device cannot be used for another. </dd></dl>

</div>
</div>
<a id="a1db0fc2951f11aef93e9ff088a0612bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db0fc2951f11aef93e9ff088a0612bc">&#9670;&nbsp;</a></span>acx_pcie_cancel_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void acx_pcie_cancel_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Achronix__PCIe_8h.html#ac4db1ffd6852a9dd694b70db54be5af3">ACX_PCIE_dev_handle</a>&#160;</td>
          <td class="paramname"><em>device_hand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interrupt_vector_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unblocks any threads waiting on the passed-in interrupt vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device_hand</td><td>A valid device handle for the device that other threads are waiting for interrupts from </td></tr>
    <tr><td class="paramname">interrupt_vector_id</td><td>Id of the interrupt vector to unblock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is only used when interacting directly with the PCIe API's driver translation layer. User applications will normally use higher-level functions from <a class="el" href="Achronix__device_8h.html" title="This file defines enums, structures and functions for opening, initializing, and closing a PCIe devic...">Achronix_device.h</a>. </dd></dl>

</div>
</div>
<a id="a5a39cd5aa93936a63cc617aa1bb987c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a39cd5aa93936a63cc617aa1bb987c7">&#9670;&nbsp;</a></span>acx_pcie_close_bar_hand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void acx_pcie_close_bar_hand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Achronix__PCIe_8h.html#a8d5b3f1a4089b9791bb15c422646193f">ACX_BAR_handle</a>&#160;</td>
          <td class="paramname"><em>bar_hand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes a device's BAR from reading/writing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bar_hand</td><td>A handle to the bar to be closed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is only used when interacting directly with the PCIe API's driver translation layer. User applications will normally use higher-level functions from <a class="el" href="Achronix__device_8h.html" title="This file defines enums, structures and functions for opening, initializing, and closing a PCIe devic...">Achronix_device.h</a>. </dd></dl>

</div>
</div>
<a id="abd32e09b578d77173959a37909bb40c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd32e09b578d77173959a37909bb40c9">&#9670;&nbsp;</a></span>acx_pcie_close_device_hand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void acx_pcie_close_device_hand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Achronix__PCIe_8h.html#ac4db1ffd6852a9dd694b70db54be5af3">ACX_PCIE_dev_handle</a>&#160;</td>
          <td class="paramname"><em>device_hand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes an ACX PCIE device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device_hand</td><td>Handle to the device to be closed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function will not cleanup any BARs or buffers associated with this device handle. It is the users responsibility to ensure that all BARS associated with this device are cleaned up, and that all DMA buffers associated with this device are freed before closing. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is only used when interacting directly with the PCIe API's driver translation layer. User applications will normally use higher-level functions from <a class="el" href="Achronix__device_8h.html" title="This file defines enums, structures and functions for opening, initializing, and closing a PCIe devic...">Achronix_device.h</a>. </dd></dl>

</div>
</div>
<a id="a8a9f5b7ab09f190c035a4d877e33cc4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9f5b7ab09f190c035a4d877e33cc4e">&#9670;&nbsp;</a></span>acx_pcie_free_dma_hand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void acx_pcie_free_dma_hand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Achronix__PCIe_8h.html#ac4db1ffd6852a9dd694b70db54be5af3">ACX_PCIE_dev_handle</a>&#160;</td>
          <td class="paramname"><em>device_hand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Achronix__PCIe_8h.html#a947d546ebc14b9e64d57e8a8a9ddfbbd">ACX_DMA_buffer_handle</a>&#160;</td>
          <td class="paramname"><em>dma_buffer_hand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a DMA buffer that was alloced with <a class="el" href="Achronix__PCIe_8h.html#a827c5207357befc8606330318f9efe98" title="Allocates a buffer in the process&#39;s virtual address space, which is backed by static physical memory,...">acx_pcie_alloc_dma_hand()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device_hand</td><td>A valid device handle for the device that is associated with the buffer handle </td></tr>
    <tr><td class="paramname">dma_buffer_hand</td><td>Handle to the buffer to be freed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is only used when interacting directly with the PCIe API's driver translation layer. User applications will normally use higher-level functions from <a class="el" href="Achronix__device_8h.html" title="This file defines enums, structures and functions for opening, initializing, and closing a PCIe devic...">Achronix_device.h</a>. </dd>
<dd>
It is the users responsibility to ensure that no DMA transactions are (or will be) running using this buffer before freeing it. Failure to do so could bring down the PCI link. </dd></dl>

</div>
</div>
<a id="ac0c09d57516a698e2237a1214ad6bfb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c09d57516a698e2237a1214ad6bfb2">&#9670;&nbsp;</a></span>acx_pcie_get_bar_idx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__lib__common.html#ga941f9eec6e2e97a778423e94e6e4025b">ACX_SDK_STATUS</a> acx_pcie_get_bar_idx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Achronix__PCIe_8h.html#a8d5b3f1a4089b9791bb15c422646193f">ACX_BAR_handle</a>&#160;</td>
          <td class="paramname"><em>bar_hand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the BAR index associated with a BAR handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">bar_hand</td><td>A valid BAR handle to read the index from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">index</td><td>Pointer to store the returned BAR index. Only valid if return is ACX_SDK_STATUS_OK. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ACX_SDK_STATUS_OK if successful </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is only used when interacting directly with the PCIe API's driver translation layer. User applications will normally use higher-level functions from <a class="el" href="Achronix__device_8h.html" title="This file defines enums, structures and functions for opening, initializing, and closing a PCIe devic...">Achronix_device.h</a>. </dd></dl>

</div>
</div>
<a id="aa273b96373e5f39e75f08f5d897b3667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa273b96373e5f39e75f08f5d897b3667">&#9670;&nbsp;</a></span>acx_pcie_get_bar_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__lib__common.html#ga941f9eec6e2e97a778423e94e6e4025b">ACX_SDK_STATUS</a> acx_pcie_get_bar_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Achronix__PCIe_8h.html#ac4db1ffd6852a9dd694b70db54be5af3">ACX_PCIE_dev_handle</a>&#160;</td>
          <td class="paramname"><em>device_hand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bar_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>size_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size (in bytes) of a device's BAR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">device_hand</td><td>A valid device handle for the device whose BAR size will be read </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">bar_id</td><td>Id of the BAR whose size is to be read </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size_ptr</td><td>Pointer to store the returned BAR size. Only valid if return is ACX_SDK_STATUS_OK. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ACX_SDK_STATUS_OK if successful </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is only used when interacting directly with the PCIe API's driver translation layer. User applications will normally use higher-level functions from <a class="el" href="Achronix__device_8h.html" title="This file defines enums, structures and functions for opening, initializing, and closing a PCIe devic...">Achronix_device.h</a>. </dd></dl>

</div>
</div>
<a id="a980ee7fa26df733575c35f73dffd697f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980ee7fa26df733575c35f73dffd697f">&#9670;&nbsp;</a></span>acx_pcie_get_bar_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__lib__common.html#ga941f9eec6e2e97a778423e94e6e4025b">ACX_SDK_STATUS</a> acx_pcie_get_bar_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Achronix__PCIe_8h.html#ac4db1ffd6852a9dd694b70db54be5af3">ACX_PCIE_dev_handle</a>&#160;</td>
          <td class="paramname"><em>device_hand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bar_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>start_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the starting address of a BAR in host physical memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">device_hand</td><td>A valid device handle for the device whose BAR starting location will be read </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">bar_id</td><td>Id of the BAR whose starting location will be read </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">start_ptr</td><td>Pointer to store the returned starting address. Only valid if return is ACX_SDK_STATUS_OK. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ACX_SDK_STATUS_OK if successful </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is only used when interacting directly with the PCIe API's driver translation layer. User applications will normally use higher-level functions from <a class="el" href="Achronix__device_8h.html" title="This file defines enums, structures and functions for opening, initializing, and closing a PCIe devic...">Achronix_device.h</a>. </dd></dl>

</div>
</div>
<a id="a8e41cb2aefcea889ecbb674e31c4d703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e41cb2aefcea889ecbb674e31c4d703">&#9670;&nbsp;</a></span>acx_pcie_get_device_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__lib__common.html#ga941f9eec6e2e97a778423e94e6e4025b">ACX_SDK_STATUS</a> acx_pcie_get_device_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Achronix__PCIe_8h.html#ac4db1ffd6852a9dd694b70db54be5af3">ACX_PCIE_dev_handle</a>&#160;</td>
          <td class="paramname"><em>device_hand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structACX__PCIE__device__info.html">ACX_PCIE_device_info</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the passed-in struct with information from the passed-in device’s config space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">device_hand</td><td>Handle to the device to get config space info from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>Pointer to an <a class="el" href="structACX__PCIE__device__info.html" title="Structure which stores some basic info from a device&#39;s config space.">ACX_PCIE_device_info</a> structure to store the results in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ACX_SDK_STATUS_OK if successful </dd></dl>

</div>
</div>
<a id="a46fbda6a3d1a4e388edc8f3a72df492e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46fbda6a3d1a4e388edc8f3a72df492e">&#9670;&nbsp;</a></span>acx_pcie_get_num_devices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t acx_pcie_get_num_devices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of devices bound to the used driver. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of devices bound to the used driver </dd></dl>

</div>
</div>
<a id="ab9dbd561ce40a9a18deeb72dd2ef4db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9dbd561ce40a9a18deeb72dd2ef4db6">&#9670;&nbsp;</a></span>acx_pcie_get_sdk_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void acx_pcie_get_sdk_version </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>major_version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>minor_version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>patch_version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets version information about the SDK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">major_version</td><td>pointer to an unsigned integer to store the major SDK version in, ignored if NULL </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">minor_version</td><td>pointer to an unsigned integer to store the minor SDK version in, ignored if NULL </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">patch_version</td><td>pointer to an unsigned integer to store the SDK patch version in, ignored if NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf9309d8e8490cf8781229e1394bc534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9309d8e8490cf8781229e1394bc534">&#9670;&nbsp;</a></span>acx_pcie_interrupt_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__lib__common.html#ga941f9eec6e2e97a778423e94e6e4025b">ACX_SDK_STATUS</a> acx_pcie_interrupt_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Achronix__PCIe_8h.html#ac4db1ffd6852a9dd694b70db54be5af3">ACX_PCIE_dev_handle</a>&#160;</td>
          <td class="paramname"><em>device_hand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interrupt_vector_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking wait for a device interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device_hand</td><td>A valid device handle for the device to wait for interrupts from </td></tr>
    <tr><td class="paramname">interrupt_vector_id</td><td>Id of the interrupt vector to wait for interrupts from </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>A timeout (in millisceonds) to wait before unblocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ACX_SDK_STATUS_OK: interrupt received ACX_SDK_STATUS_MISSED_INTERRUPT: no new interrupt, missed a previous interrupt ACX_SDK_STATUS_TIMEOUT: wait timed out, no interrupt ACX_SDK_STATUS_CANCELLED: wait was cancelled, no interrupt ACX_SDK_STATUS_ERROR: an error occurred </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The exact resolution of the timeouts is dependent on the driver implementations. The timeout parameter may be thought of as a lower bound, but may not be accurate down to the millisecond and should not be used for timing critical loops. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is only used when interacting directly with the PCIe API's driver translation layer. User applications will normally use higher-level functions from <a class="el" href="Achronix__device_8h.html" title="This file defines enums, structures and functions for opening, initializing, and closing a PCIe devic...">Achronix_device.h</a>. </dd>
<dd>
Depending on the driver implementation, a wait time of zero could be interpreted as a non-blocking check or an infinite wait time. Consult the driver's documentation for more information. </dd></dl>

</div>
</div>
<a id="abbdf67b5ede5e7f3f4bbc315ecde19a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbdf67b5ede5e7f3f4bbc315ecde19a7">&#9670;&nbsp;</a></span>acx_pcie_open_bar_hand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Achronix__PCIe_8h.html#a8d5b3f1a4089b9791bb15c422646193f">ACX_BAR_handle</a> acx_pcie_open_bar_hand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Achronix__PCIe_8h.html#ac4db1ffd6852a9dd694b70db54be5af3">ACX_PCIE_dev_handle</a>&#160;</td>
          <td class="paramname"><em>device_hand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bar_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a device's BAR for reading/writing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device_hand</td><td>A valid device handle for the device whose BAR will be opened </td></tr>
    <tr><td class="paramname">bar_id</td><td>the id of the BAR to open </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the opened BAR. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The exact implementation of the BAR initialization is driver dependent. Therefore, multiple calls to <a class="el" href="Achronix__PCIe_8h.html#abbdf67b5ede5e7f3f4bbc315ecde19a7" title="Opens a device&#39;s BAR for reading/writing.">acx_pcie_open_bar_hand()</a> for the same BAR results in undefined behavior. In general, care should be taken to always match a BAR open call with a BAR close call. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is only used when interacting directly with the PCIe API's driver translation layer. User applications will normally use higher-level functions from <a class="el" href="Achronix__device_8h.html" title="This file defines enums, structures and functions for opening, initializing, and closing a PCIe devic...">Achronix_device.h</a>. </dd></dl>

</div>
</div>
<a id="a9354e383deca85e70676e05fe6183c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9354e383deca85e70676e05fe6183c79">&#9670;&nbsp;</a></span>acx_pcie_open_device_hand_bdf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Achronix__PCIe_8h.html#ac4db1ffd6852a9dd694b70db54be5af3">ACX_PCIE_dev_handle</a> acx_pcie_open_device_hand_bdf </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>device_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens an ACX PCIE device for use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bus</td><td>The bus number of the device you wish to open </td></tr>
    <tr><td class="paramname">device_num</td><td>The device number that you wish to open </td></tr>
    <tr><td class="paramname">function</td><td>The physical function number that you wish to open </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the ACX PCIE device, or NULL on failure. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is only used when interacting directly with the PCIe API's driver translation layer. User applications will normally use higher-level functions from <a class="el" href="Achronix__device_8h.html" title="This file defines enums, structures and functions for opening, initializing, and closing a PCIe devic...">Achronix_device.h</a>. </dd></dl>

</div>
</div>
<a id="a64e19b14f8c8fb7d142ab213fffc9f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e19b14f8c8fb7d142ab213fffc9f0f">&#9670;&nbsp;</a></span>acx_pcie_open_device_hand_idx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Achronix__PCIe_8h.html#ac4db1ffd6852a9dd694b70db54be5af3">ACX_PCIE_dev_handle</a> acx_pcie_open_device_hand_idx </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>device_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens an ACX PCIE device for use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device_index</td><td>The index of the device you want to open </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the ACX PCIE device, or NULL on failure. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is only used when interacting directly with the PCIe API's driver translation layer. User applications will normally use higher-level functions from <a class="el" href="Achronix__device_8h.html" title="This file defines enums, structures and functions for opening, initializing, and closing a PCIe devic...">Achronix_device.h</a>. </dd></dl>

</div>
</div>
<a id="a97031690386ab74efc147e9dd8047092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97031690386ab74efc147e9dd8047092">&#9670;&nbsp;</a></span>acx_pcie_read_uint16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t acx_pcie_read_uint16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Achronix__PCIe_8h.html#a8d5b3f1a4089b9791bb15c422646193f">ACX_BAR_handle</a>&#160;</td>
          <td class="paramname"><em>bar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read unformatted 16-bit unsigned data from a devices BAR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">bar</td><td>A valid BAR handle to read from. The BAR handle must be associated with the device handle. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Offset (in bytes) from the start of the BAR to read the first data item from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>The data that was read from the BAR if the read was successful. Check the return status to know if the read was successful. Must be an array of size=count. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>Number of consecutive reads to perform of the given data size, starting at the offset address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes that were successfully read. If the returned number is not equal to 'count', an error occurred during reading and only the first returned number of bytes within 'data' should be considered valid. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Depending on the driver implementation, the offset parameter may need to be aligned to the size of the data being read. Consult the driver's documentation for more information about BAR alignment requirements. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is only used when interacting directly with the PCIe API's driver translation layer. User applications will normally use higher-level functions from <a class="el" href="Achronix__MMIO_8h.html" title="This file defines functions for sending low-level memory-mapped IO (read and write) requests to a PCI...">Achronix_MMIO.h</a>. </dd></dl>

</div>
</div>
<a id="aba025559ae6fa6df6228ad49a01344e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba025559ae6fa6df6228ad49a01344e2">&#9670;&nbsp;</a></span>acx_pcie_read_uint32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t acx_pcie_read_uint32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Achronix__PCIe_8h.html#a8d5b3f1a4089b9791bb15c422646193f">ACX_BAR_handle</a>&#160;</td>
          <td class="paramname"><em>bar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read unformatted 32-bit unsigned data from a devices BAR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">bar</td><td>A valid BAR handle to read from. The BAR handle must be associated with the device handle. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Offset (in bytes) from the start of the BAR to read the first data item from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>The data that was read from the BAR if the read was successful. Check the return status to know if the read was successful. Must be an array of size=count. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>Number of consecutive reads to perform of the given data size, starting at the offset address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes that were successfully read. If the returned number is not equal to 'count', an error occurred during reading and only the first returned number of bytes within 'data' should be considered valid. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Depending on the driver implementation, the offset parameter may need to be aligned to the size of the data being read. Consult the driver's documentation for more information about BAR alignment requirements. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is only used when interacting directly with the PCIe API's driver translation layer. User applications will normally use higher-level functions from <a class="el" href="Achronix__MMIO_8h.html" title="This file defines functions for sending low-level memory-mapped IO (read and write) requests to a PCI...">Achronix_MMIO.h</a>. </dd></dl>

</div>
</div>
<a id="a74ac9448a3e5f002918f4f7156904441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ac9448a3e5f002918f4f7156904441">&#9670;&nbsp;</a></span>acx_pcie_read_uint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t acx_pcie_read_uint64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Achronix__PCIe_8h.html#a8d5b3f1a4089b9791bb15c422646193f">ACX_BAR_handle</a>&#160;</td>
          <td class="paramname"><em>bar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read unformatted 64-bit unsigned data from a devices BAR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">bar</td><td>A valid BAR handle to read from. The BAR handle must be associated with the device handle. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Offset (in bytes) from the start of the BAR to read the first data item from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>The data that was read from the BAR if the read was successful. Check the return status to know if the read was successful. Must be an array of size=count. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>Number of consecutive reads to perform of the given data size, starting at the offset address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes that were successfully read. If the returned number is not equal to 'count', an error occurred during reading and only the first returned number of bytes within 'data' should be considered valid. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Depending on the driver implementation, the offset parameter may need to be aligned to the size of the data being read. Consult the driver's documentation for more information about BAR alignment requirements. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is only used when interacting directly with the PCIe API's driver translation layer. User applications will normally use higher-level functions from <a class="el" href="Achronix__MMIO_8h.html" title="This file defines functions for sending low-level memory-mapped IO (read and write) requests to a PCI...">Achronix_MMIO.h</a>. </dd></dl>

</div>
</div>
<a id="a4f25f9c01eaeb561b9943af9777d7052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f25f9c01eaeb561b9943af9777d7052">&#9670;&nbsp;</a></span>acx_pcie_read_uint8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t acx_pcie_read_uint8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Achronix__PCIe_8h.html#a8d5b3f1a4089b9791bb15c422646193f">ACX_BAR_handle</a>&#160;</td>
          <td class="paramname"><em>bar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read unformatted 8-bit unsigned data from a devices BAR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">bar</td><td>A valid BAR handle to read from. The BAR handle must be associated with the device handle. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>Offset (in bytes) from the start of the BAR to read the first data item from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>The data that was read from the BAR if the read was successful. Check the return status to know if the read was successful. Must be an array of size=count. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>Number of consecutive reads to perform of the given data size, starting at the offset address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes that were successfully read. If the returned number is not equal to 'count', an error occurred during reading and only the first returned number of bytes within 'data' should be considered valid. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Depending on the driver implementation, the offset parameter may need to be aligned to the size of the data being read. Consult the driver's documentation for more information about BAR alignment requirements. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is only used when interacting directly with the PCIe API's driver translation layer. User applications will normally use higher-level functions from <a class="el" href="Achronix__MMIO_8h.html" title="This file defines functions for sending low-level memory-mapped IO (read and write) requests to a PCI...">Achronix_MMIO.h</a>. </dd></dl>

</div>
</div>
<a id="aa682f757fe351b2d465b6b1772eacc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa682f757fe351b2d465b6b1772eacc65">&#9670;&nbsp;</a></span>acx_pcie_write_uint16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__lib__common.html#ga941f9eec6e2e97a778423e94e6e4025b">ACX_SDK_STATUS</a> acx_pcie_write_uint16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Achronix__PCIe_8h.html#a8d5b3f1a4089b9791bb15c422646193f">ACX_BAR_handle</a>&#160;</td>
          <td class="paramname"><em>bar_hand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write unformatted 16-bit unsigned data to a devices BAR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bar_hand</td><td>A valid BAR handle to write to. The BAR handle must be associated with the device handle </td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) from the start of the BAR </td></tr>
    <tr><td class="paramname">value</td><td>A uint value to write to the bar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ACX_SDK_STATUS_OK on success. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Depending on the driver implementation, the offset parameter may need to be aligned to the size of the value being read. Consult the driver's documentation for more information about BAR alignment requirements. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is only used when interacting directly with the PCIe API's driver translation layer. User applications will normally use higher-level functions from <a class="el" href="Achronix__MMIO_8h.html" title="This file defines functions for sending low-level memory-mapped IO (read and write) requests to a PCI...">Achronix_MMIO.h</a>. </dd>
<dd>
Depending on the driver implementation, writes may or may not be posted. Consult the driver's documentation for more information about write types. Posted writes may require the insertion of synchronization reads depending on the timing constraints of the hardware application. </dd></dl>

</div>
</div>
<a id="aca38a009e6d02dd8162dde3dd8be2450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca38a009e6d02dd8162dde3dd8be2450">&#9670;&nbsp;</a></span>acx_pcie_write_uint32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__lib__common.html#ga941f9eec6e2e97a778423e94e6e4025b">ACX_SDK_STATUS</a> acx_pcie_write_uint32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Achronix__PCIe_8h.html#a8d5b3f1a4089b9791bb15c422646193f">ACX_BAR_handle</a>&#160;</td>
          <td class="paramname"><em>bar_hand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write unformatted 32-bit unsigned data to a devices BAR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bar_hand</td><td>A valid BAR handle to write to. The BAR handle must be associated with the device handle </td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) from the start of the BAR </td></tr>
    <tr><td class="paramname">value</td><td>A uint value to write to the bar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ACX_SDK_STATUS_OK on success. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Depending on the driver implementation, the offset parameter may need to be aligned to the size of the value being read. Consult the driver's documentation for more information about BAR alignment requirements. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is only used when interacting directly with the PCIe API's driver translation layer. User applications will normally use higher-level functions from <a class="el" href="Achronix__MMIO_8h.html" title="This file defines functions for sending low-level memory-mapped IO (read and write) requests to a PCI...">Achronix_MMIO.h</a>. </dd>
<dd>
Depending on the driver implementation, writes may or may not be posted. Consult the driver's documentation for more information about write types. Posted writes may require the insertion of synchronization reads depending on the timing constraints of the hardware application. </dd></dl>

</div>
</div>
<a id="a8cfd7035cf0c0d4262e01fde49a7264f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cfd7035cf0c0d4262e01fde49a7264f">&#9670;&nbsp;</a></span>acx_pcie_write_uint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__lib__common.html#ga941f9eec6e2e97a778423e94e6e4025b">ACX_SDK_STATUS</a> acx_pcie_write_uint64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Achronix__PCIe_8h.html#a8d5b3f1a4089b9791bb15c422646193f">ACX_BAR_handle</a>&#160;</td>
          <td class="paramname"><em>bar_hand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write unformatted 64-bit unsigned data to a devices BAR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bar_hand</td><td>A valid BAR handle to write to. The BAR handle must be associated with the device handle </td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) from the start of the BAR </td></tr>
    <tr><td class="paramname">value</td><td>A uint value to write to the bar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ACX_SDK_STATUS_OK on success. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Depending on the driver implementation, the offset parameter may need to be aligned to the size of the value being read. Consult the driver's documentation for more information about BAR alignment requirements. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is only used when interacting directly with the PCIe API's driver translation layer. User applications will normally use higher-level functions from <a class="el" href="Achronix__MMIO_8h.html" title="This file defines functions for sending low-level memory-mapped IO (read and write) requests to a PCI...">Achronix_MMIO.h</a>. </dd>
<dd>
Depending on the driver implementation, writes may or may not be posted. Consult the driver's documentation for more information about write types. Posted writes may require the insertion of synchronization reads depending on the timing constraints of the hardware application. </dd></dl>

</div>
</div>
<a id="a301b8e0a78e9d33ae8eea4066dc9520d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301b8e0a78e9d33ae8eea4066dc9520d">&#9670;&nbsp;</a></span>acx_pcie_write_uint8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__lib__common.html#ga941f9eec6e2e97a778423e94e6e4025b">ACX_SDK_STATUS</a> acx_pcie_write_uint8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Achronix__PCIe_8h.html#a8d5b3f1a4089b9791bb15c422646193f">ACX_BAR_handle</a>&#160;</td>
          <td class="paramname"><em>bar_hand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write unformatted 8-bit unsigned data to a devices BAR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bar_hand</td><td>A valid BAR handle to write to. The BAR handle must be associated with the device handle </td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) from the start of the BAR </td></tr>
    <tr><td class="paramname">value</td><td>A uint value to write to the bar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ACX_SDK_STATUS_OK on success. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Depending on the driver implementation, the offset parameter may need to be aligned to the size of the value being read. Consult the driver's documentation for more information about BAR alignment requirements. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is only used when interacting directly with the PCIe API's driver translation layer. User applications will normally use higher-level functions from <a class="el" href="Achronix__MMIO_8h.html" title="This file defines functions for sending low-level memory-mapped IO (read and write) requests to a PCI...">Achronix_MMIO.h</a>. </dd>
<dd>
Depending on the driver implementation, writes may or may not be posted. Consult the driver's documentation for more information about write types. Posted writes may require the insertion of synchronization reads depending on the timing constraints of the hardware application. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="Achronix__PCIe_8c.html">Achronix_PCIe.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
