<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Achronix Software Development Kit (SDK): SDK Library Driver Independent PCIe Device Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Achronix Software Development Kit (SDK)
   </div>
   <div id="projectbrief">Copyright (c) 2022-2023 Achronix Semiconductor. Some Rights Reserved.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__sdk__lib__device.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SDK Library Driver Independent PCIe Device Interface<div class="ingroups"><a class="el" href="group__sdk__lib.html">SDK Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>SDK interface for driver independent PCIe devices.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionACX__DEV__DBIx16__access__reg.html">ACX_DEV_DBIx16_access_reg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union containing an anonymous struct describing the individual bitfields for the DBI access registers in the x16 PCIe interface.  <a href="unionACX__DEV__DBIx16__access__reg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionACX__DEV__DBIx8__access__reg.html">ACX_DEV_DBIx8_access_reg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union containing an anonymous structure describing the individual bitfields for the DBI access registers in the x8 PCIe interface.  <a href="unionACX__DEV__DBIx8__access__reg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structACX__DEV__PCIe__device.html">ACX_DEV_PCIe_device</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A high level struct that manages state for a PCIe device.  <a href="structACX__DEV__PCIe__device.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaf3e68230c10181d6597be397de0ee126"><td class="memItemLeft" align="right" valign="top"><a id="gaf3e68230c10181d6597be397de0ee126"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdk__lib__device.html#gaf3e68230c10181d6597be397de0ee126">ACX_GDDR6_SPACE</a>&#160;&#160;&#160;(uint64_t)0x00000000000</td></tr>
<tr class="memdesc:gaf3e68230c10181d6597be397de0ee126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base address of the GDDR6 endpoint in the 42-bit NOC address space. <br /></td></tr>
<tr class="separator:gaf3e68230c10181d6597be397de0ee126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d3cd1638fb69abf2a7ddd346265bae3"><td class="memItemLeft" align="right" valign="top"><a id="ga3d3cd1638fb69abf2a7ddd346265bae3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdk__lib__device.html#ga3d3cd1638fb69abf2a7ddd346265bae3">ACX_NAP_SPACE</a>&#160;&#160;&#160;(uint64_t)0x04000000000</td></tr>
<tr class="memdesc:ga3d3cd1638fb69abf2a7ddd346265bae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base address of the NAP endpoints in the 42-bit NOC address space. <br /></td></tr>
<tr class="separator:ga3d3cd1638fb69abf2a7ddd346265bae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e04a7e37e03942bd122d59ceee22723"><td class="memItemLeft" align="right" valign="top"><a id="ga1e04a7e37e03942bd122d59ceee22723"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdk__lib__device.html#ga1e04a7e37e03942bd122d59ceee22723">ACX_CSR_SPACE</a>&#160;&#160;&#160;(uint64_t)0x08000000000</td></tr>
<tr class="memdesc:ga1e04a7e37e03942bd122d59ceee22723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base address of the Constrol Status Registers (CSR) endpoint in the 42-bit NOC address space. <br /></td></tr>
<tr class="separator:ga1e04a7e37e03942bd122d59ceee22723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacba1daac6b014b0cae5a4e3651c28d6d"><td class="memItemLeft" align="right" valign="top"><a id="gacba1daac6b014b0cae5a4e3651c28d6d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdk__lib__device.html#gacba1daac6b014b0cae5a4e3651c28d6d">ACX_FCU_SPACE</a>&#160;&#160;&#160;(uint64_t)0x0C000000000</td></tr>
<tr class="memdesc:gacba1daac6b014b0cae5a4e3651c28d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base address of the FPGA Control Unit (FCU) endpoint in the 42-bit NOC address space. <br /></td></tr>
<tr class="separator:gacba1daac6b014b0cae5a4e3651c28d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8dd591e920568e94ed367176f7dd912"><td class="memItemLeft" align="right" valign="top"><a id="gaa8dd591e920568e94ed367176f7dd912"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdk__lib__device.html#gaa8dd591e920568e94ed367176f7dd912">ACX_DDR4_SPACE</a>&#160;&#160;&#160;(uint64_t)0x10000000000</td></tr>
<tr class="memdesc:gaa8dd591e920568e94ed367176f7dd912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base address of the DDR4 endpoint in the 42-bit NOC address space. <br /></td></tr>
<tr class="separator:gaa8dd591e920568e94ed367176f7dd912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b3ec4c3df0ef7f9dd85d3174886d014"><td class="memItemLeft" align="right" valign="top"><a id="ga7b3ec4c3df0ef7f9dd85d3174886d014"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdk__lib__device.html#ga7b3ec4c3df0ef7f9dd85d3174886d014">ACX_NUM_BARS</a>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:ga7b3ec4c3df0ef7f9dd85d3174886d014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of Base Address Registers (BARs) defined by the device. <br /></td></tr>
<tr class="separator:ga7b3ec4c3df0ef7f9dd85d3174886d014"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga2a84f59fe7d91ab754fb85b9d4f7116f"><td class="memItemLeft" align="right" valign="top"><a id="ga2a84f59fe7d91ab754fb85b9d4f7116f"></a>
typedef struct _ACX_IP_block&#160;</td><td class="memItemRight" valign="bottom"><b>ACX_IP_block</b></td></tr>
<tr class="separator:ga2a84f59fe7d91ab754fb85b9d4f7116f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga5f9fb93bca7235c5416e47756022994a"><td class="memItemLeft" align="right" valign="top"><a id="ga5f9fb93bca7235c5416e47756022994a"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdk__lib__device.html#ga5f9fb93bca7235c5416e47756022994a">ACX_DEV_PART_NAME</a> { <b>ACX_PART_AC7t1500</b>
, <b>ACX_PART_AC7t1400</b>
, <b>ACX_PART_AC7t800ES0</b>
 }</td></tr>
<tr class="memdesc:ga5f9fb93bca7235c5416e47756022994a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to describe the part number of the Achronix FPGA in the PCIe device. <br /></td></tr>
<tr class="separator:ga5f9fb93bca7235c5416e47756022994a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga122df86b07f5032da1bc26f18e2dde0a"><td class="memItemLeft" align="right" valign="top"><a id="ga122df86b07f5032da1bc26f18e2dde0a"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdk__lib__device.html#ga122df86b07f5032da1bc26f18e2dde0a">acx_part_name_to_string</a> (<a class="el" href="group__sdk__lib__device.html#ga5f9fb93bca7235c5416e47756022994a">ACX_DEV_PART_NAME</a> name)</td></tr>
<tr class="memdesc:ga122df86b07f5032da1bc26f18e2dde0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an ACX_DEV_PART_NAME into a printable string. <br /></td></tr>
<tr class="separator:ga122df86b07f5032da1bc26f18e2dde0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fde38d7edc1ee2b2c4c6513fd7731dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structACX__DEV__PCIe__device.html">ACX_DEV_PCIe_device</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdk__lib__device.html#ga9fde38d7edc1ee2b2c4c6513fd7731dc">acx_dev_init_pcie_device_idx</a> (uint32_t device_id)</td></tr>
<tr class="memdesc:ga9fde38d7edc1ee2b2c4c6513fd7731dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">High level function to open a PCIe device and its BARs, and to create/initialize the device's IP blocks for use.  <a href="group__sdk__lib__device.html#ga9fde38d7edc1ee2b2c4c6513fd7731dc">More...</a><br /></td></tr>
<tr class="separator:ga9fde38d7edc1ee2b2c4c6513fd7731dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc8b2378ea85762745494c805410c781"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structACX__DEV__PCIe__device.html">ACX_DEV_PCIe_device</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdk__lib__device.html#gadc8b2378ea85762745494c805410c781">acx_dev_init_pcie_device_bdf</a> (uint32_t bus, uint32_t device, uint32_t function)</td></tr>
<tr class="memdesc:gadc8b2378ea85762745494c805410c781"><td class="mdescLeft">&#160;</td><td class="mdescRight">High level function to open a PCIe device and its BARs, and to create/initialize the device's IP blocks for use.  <a href="group__sdk__lib__device.html#gadc8b2378ea85762745494c805410c781">More...</a><br /></td></tr>
<tr class="separator:gadc8b2378ea85762745494c805410c781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6895d254d0217c3b7ee87713d6448c4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdk__lib__device.html#ga6895d254d0217c3b7ee87713d6448c4a">acx_dev_cleanup_pcie_device</a> (<a class="el" href="structACX__DEV__PCIe__device.html">ACX_DEV_PCIe_device</a> *device)</td></tr>
<tr class="memdesc:ga6895d254d0217c3b7ee87713d6448c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-level function to cleanup a device, its bars, and its IP blocks.  <a href="group__sdk__lib__device.html#ga6895d254d0217c3b7ee87713d6448c4a">More...</a><br /></td></tr>
<tr class="separator:ga6895d254d0217c3b7ee87713d6448c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5734eb6db98ffbf3bce0552e7e0db6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__lib__common.html#ga941f9eec6e2e97a778423e94e6e4025b">ACX_SDK_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdk__lib__device.html#gac5734eb6db98ffbf3bce0552e7e0db6c">acx_dev_is_fabric_ready</a> (<a class="el" href="structACX__DEV__PCIe__device.html">ACX_DEV_PCIe_device</a> *device)</td></tr>
<tr class="memdesc:gac5734eb6db98ffbf3bce0552e7e0db6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to check if the FPGA fabric on the device is ready for use  <a href="group__sdk__lib__device.html#gac5734eb6db98ffbf3bce0552e7e0db6c">More...</a><br /></td></tr>
<tr class="separator:gac5734eb6db98ffbf3bce0552e7e0db6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>SDK interface for driver independent PCIe devices. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6895d254d0217c3b7ee87713d6448c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6895d254d0217c3b7ee87713d6448c4a">&#9670;&nbsp;</a></span>acx_dev_cleanup_pcie_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void acx_dev_cleanup_pcie_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structACX__DEV__PCIe__device.html">ACX_DEV_PCIe_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High-level function to cleanup a device, its bars, and its IP blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>pointer to the device to be cleaned up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the device pointer should be discarded after calling this function. </dd>
<dd>
Since the '<a class="el" href="structACX__DEV__PCIe__device.html" title="A high level struct that manages state for a PCIe device.">ACX_DEV_PCIe_device</a>' strucutre is backed by a hardware device only one active '<a class="el" href="structACX__DEV__PCIe__device.html" title="A high level struct that manages state for a PCIe device.">ACX_DEV_PCIe_device</a>' is allowed. Internally the SDK will keep a reference counter to the '<a class="el" href="structACX__DEV__PCIe__device.html" title="A high level struct that manages state for a PCIe device.">ACX_DEV_PCIe_device</a>' on a per process level. If there is more than one reference to an opened device then within a process then calling this function will decrement the reference counter. If this function is called with the last remaining device reference then the internal pointers will be freed and the IP cleaner functions will be called. Reference counting of structures across different processes is not supported and may lead to race conditions. </dd></dl>

</div>
</div>
<a id="gadc8b2378ea85762745494c805410c781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc8b2378ea85762745494c805410c781">&#9670;&nbsp;</a></span>acx_dev_init_pcie_device_bdf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structACX__DEV__PCIe__device.html">ACX_DEV_PCIe_device</a>* acx_dev_init_pcie_device_bdf </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High level function to open a PCIe device and its BARs, and to create/initialize the device's IP blocks for use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bus</td><td>The bus number that the dvice you wish to initialize is on. </td></tr>
    <tr><td class="paramname">device</td><td>The device number that you wish to initiailize. </td></tr>
    <tr><td class="paramname">function</td><td>The physical device function that you wish to initialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an <a class="el" href="structACX__DEV__PCIe__device.html" title="A high level struct that manages state for a PCIe device.">ACX_DEV_PCIe_device</a> structure if successful, or NULL on error. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The device status will be ACX_SDK_STATUS_OK if initialization was successful. It's possible for BAR opening to fail. In this case a device struct will still be returned and the device status will be ACX_DEV_STATUS_BAR_OPEN_FAIL. The device will be open, but not all the BARs will be in a usable state. It is up to the application to decide if this error case is recoverable or not. </dd>
<dd>
Since the '<a class="el" href="structACX__DEV__PCIe__device.html" title="A high level struct that manages state for a PCIe device.">ACX_DEV_PCIe_device</a>' structure is backed by a hardware device only one active '<a class="el" href="structACX__DEV__PCIe__device.html" title="A high level struct that manages state for a PCIe device.">ACX_DEV_PCIe_device</a>' is allowed. Internally the SDK will keep a reference counter to the '<a class="el" href="structACX__DEV__PCIe__device.html" title="A high level struct that manages state for a PCIe device.">ACX_DEV_PCIe_device</a>' on a per process level. If acx_dev_init_pcie_device() is called multiple times then each returned structure will share the same pointers and the initializer functions will only be called for the first fresh instance of the an '<a class="el" href="structACX__DEV__PCIe__device.html" title="A high level struct that manages state for a PCIe device.">ACX_DEV_PCIe_device</a>' structure. Reference counting of structures across different processes is not supported and may lead to race conditions. </dd></dl>

</div>
</div>
<a id="ga9fde38d7edc1ee2b2c4c6513fd7731dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fde38d7edc1ee2b2c4c6513fd7731dc">&#9670;&nbsp;</a></span>acx_dev_init_pcie_device_idx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structACX__DEV__PCIe__device.html">ACX_DEV_PCIe_device</a>* acx_dev_init_pcie_device_idx </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>device_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High level function to open a PCIe device and its BARs, and to create/initialize the device's IP blocks for use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device_id</td><td>The index of the device to open </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an <a class="el" href="structACX__DEV__PCIe__device.html" title="A high level struct that manages state for a PCIe device.">ACX_DEV_PCIe_device</a> structure if successful, or NULL on error. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The device index is determined by the order in which the operating system enumerated the attached PCIe devices. </dd>
<dd>
The device status will be ACX_SDK_STATUS_OK if initialization was successful. It's possible for BAR opening to fail. In this case a device struct will still be returned and the device status will be ACX_DEV_STATUS_BAR_OPEN_FAIL. The device will be open, but not all the BARs will be in a usable state. It is up to the application to decide if this error case is recoverable or not. </dd>
<dd>
Since the '<a class="el" href="structACX__DEV__PCIe__device.html" title="A high level struct that manages state for a PCIe device.">ACX_DEV_PCIe_device</a>' structure is backed by a hardware device only one active '<a class="el" href="structACX__DEV__PCIe__device.html" title="A high level struct that manages state for a PCIe device.">ACX_DEV_PCIe_device</a>' is allowed. Internally the SDK will keep a reference counter to the '<a class="el" href="structACX__DEV__PCIe__device.html" title="A high level struct that manages state for a PCIe device.">ACX_DEV_PCIe_device</a>' on a per process level. If acx_dev_init_pcie_device() is called multiple times then each returned structure will share the same pointers and the initializer functions will only be called for the first fresh instance of the an '<a class="el" href="structACX__DEV__PCIe__device.html" title="A high level struct that manages state for a PCIe device.">ACX_DEV_PCIe_device</a>' structure. Reference counting of structures across different processes is not supported and may lead to race conditions. </dd></dl>

</div>
</div>
<a id="gac5734eb6db98ffbf3bce0552e7e0db6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5734eb6db98ffbf3bce0552e7e0db6c">&#9670;&nbsp;</a></span>acx_dev_is_fabric_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__lib__common.html#ga941f9eec6e2e97a778423e94e6e4025b">ACX_SDK_STATUS</a> acx_dev_is_fabric_ready </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structACX__DEV__PCIe__device.html">ACX_DEV_PCIe_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function to check if the FPGA fabric on the device is ready for use </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>pointer to the device to check fabric for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ACX_SDK_STATUS_OK if fabric is out of reset ACX_SDK_STATUS_NOT_READY if the fabric is still in reset ACX_SDK_STATUS_TARGET_NULL if the device pointer was null ACX_SDK_STATUS_ERROR if the fabric state could not be read</dd></dl>
<p>This function is meant to check if the bitstream on the device is a stage0 bitstream or stage1 bitstream. During stage0 of two-stage programming, only the PCIe controller has been programmed. This function returns 'ACX_SDK_STATUS_OK' when the stage-1 bitstream has completed loading, and the fabric has entered user-mode.'IP_block' initializers should use this function when a design is using two-stage programming in order to know if stage1 has finished loading. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
